<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Bar Segments with Pen Tool</title>
    <style>
        canvas {
            border: 0px solid black;
        }
        .controls {
            margin-top: 10px;
        }
        .controls button {
            margin-right: 5px;
        }
        #penToolBtn.active {
            background-color: #00aaff;
            color: white;
        }
        .color-picker {
            display: none;
            position: absolute;
            background-color: white;
            border: 1px solid #ccc;
            padding: 10px;
            width: 230px;
        }
        .color-picker div {
            display: inline-block;
            width: 30px;
            height: 30px;
            margin: 2px;
            cursor: pointer;
            border: 1px solid #000;
            transition: transform 0.2s;
        }
        .color-picker div:hover {
            transform: scale(1.2);
        }
        .label-text {
            position: absolute;
            border: 1px solid black;
            padding: 5px;
            background-color: white;
            cursor: move;
            user-select: none;
        }
    </style>
</head>
<body>

<canvas id="barCanvas" width="1500" height="500"></canvas>
<div class="controls">
    <button id="addSegment">+</button>
    <button id="undoBtn">Undo</button>
    <button id="addTextBox">Add Label</button>
    <button id="penToolBtn">Toggle Pen Tool</button>
    <button id="saveBtn">Save</button>
    <button id="loadBtn">Load</button>
</div>

<div class="color-picker" id="colorPicker">
    <div style="background-color: #1f2f56;"></div>
    <div style="background-color: #2c3e70;"></div>
    <div style="background-color: #3b4f85;"></div>
    <div style="background-color: #4c6099;"></div>
    <div style="background-color: #5b70ad;"></div>
    <div style="background-color: #6b80c0;"></div>
    <div style="background-color: #7a91d4;"></div>
    <div style="background-color: #8ba2e7;"></div>
    <div style="background-color: #9bb3fa;"></div>
    <div style="background-color: #acbdf0;"></div>

    <div style="background-color: #1c1e20;"></div>
    <div style="background-color: #2e3133;"></div>
    <div style="background-color: #404447;"></div>
    <div style="background-color: #525659;"></div>
    <div style="background-color: #63676b;"></div>
    <div style="background-color: #767a7e;"></div>
    <div style="background-color: #888c90;"></div>
    <div style="background-color: #9a9ea2;"></div>
    <div style="background-color: #acb0b4;"></div>
    <div style="background-color: #bec2c6;"></div>

    <button id="deleteSegment">Delete Segment</button>
    <button id="closeColorPicker">Close</button>
</div>

<script>
    const canvas = document.getElementById('barCanvas');
    const ctx = canvas.getContext('2d');
    const bufferCanvas = document.createElement('canvas');
    bufferCanvas.width = canvas.width;
    bufferCanvas.height = canvas.height;
    const bufferCtx = bufferCanvas.getContext('2d');
    const undoStack = [];
    const colorPicker = document.getElementById('colorPicker');
    let segments = [{ start: 100, width: 800, color: '#1f2f56' }];
    let draggingSegment = null;
    let selectedSegment = null;
    let draggingEdge = null;
    let lastMouseX = 0;
    let penToolActive = false;
    let drawing = false;
    let textBoxes = [];
    let draggingTextBox = null;
    const edgeThreshold = 5;

    // Custom color palette for random selection
    const customColors = [
        '#1f2f56', '#2c3e70', '#3b4f85', '#4c6099', '#5b70ad', '#6b80c0', '#7a91d4',
        '#8ba2e7', '#9bb3fa', '#acbdf0', '#1c1e20', '#2e3133', '#404447', '#525659',
        '#63676b', '#767a7e', '#888c90', '#9a9ea2', '#acb0b4', '#bec2c6'
    ];

    // Draw segments on canvas
    function drawSegments() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(bufferCanvas, 0, 0); // Preserve drawings
        segments.forEach(segment => {
            ctx.fillStyle = segment.color;
            ctx.fillRect(segment.start, 180, segment.width, 40);
            ctx.strokeRect(segment.start, 180, segment.width, 40);
        });
    }

    // Save current state to undo stack
    function saveState() {
        const imageData = bufferCtx.getImageData(0, 0, canvas.width, canvas.height); // Buffer for drawings
        undoStack.push({
            segments: JSON.parse(JSON.stringify(segments)),
            textBoxes: textBoxes.map(tb => ({ text: tb.innerText, x: tb.style.left, y: tb.style.top })),
            canvasData: imageData
        });
    }

    // Undo functionality
    document.getElementById('undoBtn').addEventListener('click', () => {
        if (undoStack.length > 0) {
            const { segments: savedSegments, textBoxes: savedTextBoxes, canvasData } = undoStack.pop();
            segments = savedSegments;

            bufferCtx.putImageData(canvasData, 0, 0); // Restore drawing from buffer
            drawSegments();

            // Clear and reload text boxes
            textBoxes.forEach(tb => tb.remove());
            textBoxes = [];
            savedTextBoxes.forEach(({ text, x, y }) => {
                const textBox = createTextBox(text, x, y);
                textBoxes.push(textBox);
            });

            drawSegments();
        }
    });

    // Pen Tool toggle
    document.getElementById('penToolBtn').addEventListener('click', (e) => {
        togglePenTool(e.target);
    });

    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && penToolActive) {
            togglePenTool(document.getElementById('penToolBtn'), true);
        }
    });

    // Toggle pen tool and update UI
    function togglePenTool(button, forceOff = false) {
        penToolActive = forceOff ? false : !penToolActive;
        if (penToolActive) {
            button.classList.add('active');
            button.innerText = 'Pen Tool (On)';
            canvas.style.cursor = 'crosshair';
        } else {
            button.classList.remove('active');
            button.innerText = 'Toggle Pen Tool';
            canvas.style.cursor = 'default';
        }
    }

    // Start drawing with pen tool
    canvas.addEventListener('mousedown', (e) => {
        if (penToolActive) {
            saveState();
            drawing = true;
            bufferCtx.beginPath();
            bufferCtx.moveTo(e.offsetX, e.offsetY);
        }
    });

    canvas.addEventListener('mousemove', (e) => {
        if (penToolActive && drawing) {
            bufferCtx.lineTo(e.offsetX, e.offsetY);
            bufferCtx.stroke();
            drawSegments();
        }
    });

    canvas.addEventListener('mouseup', () => {
        if (penToolActive && drawing) {
            drawing = false;
            bufferCtx.closePath();
        }
    });

    // Check if clicked on an edge for resizing
    function hitTestEdge(x) {
        // Check for left edge of first segment
        if (Math.abs(x - segments[0].start) <= edgeThreshold) {
            return { index: 0, edge: 'left' };
        }

        // Check for right edge of last segment
        if (Math.abs(x - (segments[segments.length - 1].start + segments[segments.length - 1].width)) <= edgeThreshold) {
            return { index: segments.length - 1, edge: 'right' };
        }

        // Check between segments
        for (let i = 0; i < segments.length - 1; i++) {
            let seg = segments[i];
            if (Math.abs(x - (seg.start + seg.width)) <= edgeThreshold) {
                return { index: i, edge: 'between' };
            }
        }
        return null;
    }

    // Check if clicked on a segment
    function hitTestSegment(x) {
        for (let i = 0; i < segments.length; i++) {
            let seg = segments[i];
            if (x >= seg.start && x <= seg.start + seg.width) {
                return i;
            }
        }
        return null;
    }

    // Handle mousedown for segment dragging/resizing
    canvas.addEventListener('mousedown', (e) => {
        if (!penToolActive) {
            let x = e.offsetX;
            draggingEdge = hitTestEdge(x);

            if (draggingEdge === null) {
                draggingSegment = hitTestSegment(x);
            }

            if (draggingSegment !== null || draggingEdge !== null) {
                lastMouseX = x;
                saveState();
            }
        }
    });

    // Handle mousemove for dragging/resizing
    canvas.addEventListener('mousemove', (e) => {
        if (!penToolActive) {
            let x = e.offsetX;
            let deltaX = x - lastMouseX;

            if (draggingEdge !== null && deltaX !== 0) {
                if (draggingEdge.edge === 'left') {
                    resizeLeftEdge(draggingEdge.index, deltaX);
                } else if (draggingEdge.edge === 'right') {
                    resizeRightEdge(draggingEdge.index, deltaX);
                } else if (draggingEdge.edge === 'between') {
                    resizeAdjacentSegments(draggingEdge.index, deltaX);
                }
                lastMouseX = x;
            }

            if (draggingSegment !== null && deltaX !== 0) {
                if (deltaX > 0) {
                    moveSegmentsRight(deltaX);
                } else {
                    moveSegmentsLeft(deltaX);
                }
                lastMouseX = x;
            }
        }
    });

    // Stop dragging
    canvas.addEventListener('mouseup', () => {
        draggingSegment = null;
        draggingEdge = null;
    });

    // Handle segment resizing between segments
    function resizeAdjacentSegments(edgeIndex, deltaX) {
        let segment = segments[edgeIndex];
        let nextSegment = segments[edgeIndex + 1];
        let totalWidth = segment.width + nextSegment.width;
        let newWidth = segment.width + deltaX;

        if (newWidth >= 0 && newWidth <= totalWidth) {
            segment.width = newWidth;
            nextSegment.width = totalWidth - newWidth;
            nextSegment.start = segment.start + segment.width;
            drawSegments();
        }
    }

    // Resize left edge of the first segment
    function resizeLeftEdge(segmentIndex, deltaX) {
        let segment = segments[segmentIndex];
        let newStart = segment.start + deltaX;
        let newWidth = segment.width - deltaX;

        if (newWidth >= 10) {
            segment.start = newStart;
            segment.width = newWidth;
            drawSegments();
        }
    }

    // Resize right edge of the last segment
    function resizeRightEdge(segmentIndex, deltaX) {
        let segment = segments[segmentIndex];
        let newWidth = segment.width + deltaX;

        if (newWidth >= 10) {
            segment.width = newWidth;
            drawSegments();
        }
    }

    // Move segments to the right
    function moveSegmentsRight(deltaX) {
        let segment = segments[draggingSegment];
        let leftSegment = segments[draggingSegment - 1];

        for (let i = draggingSegment; i < segments.length; i++) {
            segments[i].start += deltaX;
        }

        if (leftSegment) {
            leftSegment.width += deltaX;
        }

        drawSegments();
    }

    // Move segments to the left
    function moveSegmentsLeft(deltaX) {
        let segment = segments[draggingSegment];
        let rightSegment = segments[draggingSegment + 1];

        for (let i = draggingSegment; i >= 0; i--) {
            segments[i].start += deltaX;
        }

        if (rightSegment) {
            rightSegment.width -= deltaX;
            rightSegment.start = segment.start + segment.width;
        }

        drawSegments();
    }

    // Add a new segment and change one half to a custom color
    document.getElementById('addSegment').addEventListener('click', () => {
        saveState();
        let largestSegment = segments.reduce((a, b) => (a.width > b.width ? a : b));
        let splitPoint = largestSegment.start + largestSegment.width / 2;

        let firstHalf = {
            start: largestSegment.start,
            width: largestSegment.width / 2,
            color: largestSegment.color // Keep the original color
        };
        let secondHalf = {
            start: splitPoint,
            width: largestSegment.width / 2,
            color: customColors[Math.floor(Math.random() * customColors.length)] // Random custom color
        };

        let index = segments.indexOf(largestSegment);
        segments.splice(index, 1, firstHalf, secondHalf);
        drawSegments();
    });

    // Handle double-click to open color picker or delete segment
    canvas.addEventListener('dblclick', (e) => {
        let x = e.offsetX;
        selectedSegment = hitTestSegment(x);
        if (selectedSegment !== null) {
            colorPicker.style.display = 'block';
            colorPicker.style.left = e.pageX + 'px';
            colorPicker.style.top = e.pageY + 'px';
        }
    });

    // Handle color picker selection
    document.querySelectorAll('.color-picker div').forEach(colorBox => {
        colorBox.addEventListener('click', (e) => {
            if (selectedSegment !== null) {
                segments[selectedSegment].color = e.target.style.backgroundColor;
                drawSegments();
                colorPicker.style.display = 'none';
            }
        });
    });

    // Delete segment functionality
    document.getElementById('deleteSegment').addEventListener('click', () => {
        if (selectedSegment !== null) {
            saveState();
            const deletedSegmentWidth = segments[selectedSegment].width;
            segments.splice(selectedSegment, 1);

            // Adjust the positions of remaining segments to close the gap
            for (let i = selectedSegment; i < segments.length; i++) {
                segments[i].start -= deletedSegmentWidth;
            }

            drawSegments();
            colorPicker.style.display = 'none';
        }
    });

    // Close color picker
    document.getElementById('closeColorPicker').addEventListener('click', () => {
        colorPicker.style.display = 'none';
    });

    // Save the current state to localStorage
    document.getElementById('saveBtn').addEventListener('click', () => {
        const data = {
            segments,
            textBoxes: textBoxes.map(tb => ({ text: tb.innerText, x: tb.style.left, y: tb.style.top }))
        };
        localStorage.setItem('barData', JSON.stringify(data));
    });

    // Load the state from localStorage
    document.getElementById('loadBtn').addEventListener('click', () => {
        const savedData = localStorage.getItem('barData');
        if (savedData) {
            const { segments: savedSegments, textBoxes: savedTextBoxes } = JSON.parse(savedData);
            segments = savedSegments;

            // Clear and reload text boxes
            textBoxes.forEach(tb => tb.remove());
            textBoxes = [];
            savedTextBoxes.forEach(({ text, x, y }) => {
                const textBox = createTextBox(text, x, y);
                textBoxes.push(textBox);
            });

            drawSegments();
        }
    });

    // Create a text box
    function createTextBox(text, x, y) {
        const textBox = document.createElement('div');
        textBox.className = 'label-text';
        textBox.contentEditable = true;
        textBox.innerText = text || 'Label';
        textBox.style.left = x || '100px';
        textBox.style.top = y || '200px';
        document.body.appendChild(textBox);

        // Handle dragging of text boxes
        textBox.addEventListener('mousedown', (e) => {
            saveState();
            draggingTextBox = textBox;
            const shiftX = e.clientX - textBox.getBoundingClientRect().left;
            const shiftY = e.clientY - textBox.getBoundingClientRect().top;

            function onMouseMove(e) {
                textBox.style.left = e.pageX - shiftX + 'px';
                textBox.style.top = e.pageY - shiftY + 'px';
            }

            document.addEventListener('mousemove', onMouseMove);

            document.addEventListener('mouseup', () => {
                document.removeEventListener('mousemove', onMouseMove);
            }, { once: true });
        });

        // Handle double-click to delete text box
        textBox.addEventListener('dblclick', () => {
            textBox.remove();
            textBoxes = textBoxes.filter(tb => tb !== textBox);
        });

        return textBox;
    }

    // Add label text box functionality
    document.getElementById('addTextBox').addEventListener('click', () => {
        const textBox = createTextBox();
        textBoxes.push(textBox);
    });

    // Initial draw
    drawSegments();
</script>

</body>
</html>
